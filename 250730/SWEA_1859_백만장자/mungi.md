## 1) 백만 장자 프로젝트 - SWEA 1859
**b. 아이디어**
  + 사용 알고리즘: 완전 탐색..?
  + 접근 방법 요약:
      1. 이득을 보기 위해선 고점일 때 구매하면 안됩니다.
      2. 고점인 날을 찾고, 그 날을 기준으로 리스트를 분리합니다.
      3. 고점 이후의 날 리스트에서 또 고점을 찾고, 리스트를 분리하는 반복을 시행하면 되지 않을까라고 생각했습니다만
      4. 코드 구현이 어려웠기도하고 시간 초과났다는 댓글을 본 기억이 나서..
      5. 고민하던 중, 뒤에서부터 접근하면 어떨까라는 생각이 들었습니다.
      6. 고점이 뒤에 있을 수록 이득이 커지기 때문이죠.
      7. 117254를 예로 들면, 4는 5보다 작으므로 넘어갑니다
      8. 5는 2보다 크므로 우선 최댓값으로 저장하고, 2와의 차이인 3을 이득볼 수 있습니다.
      9. 7은 5보다 크므로 최댓값은 7로 갱신합니다. 이러한 일련의 과정을 반복해주는 것이죠.
 
  **c. 코드 (Python)**
```python

T = int(input()) # Test case 개수
 
for test_case in range(1, T+1):
    N = int(input())
    M = list(map(int, input().split()))
    maximum = 0 # maximum값을 저장할거에요
    # 처음 리뷰할 땐 max로 변수명을 지정했었는데, LEGB Rule에 따라,
    # Local과 Built-in이 겹치면 max 함수를 못쓰게 되는 것이에요..그래서 maximum으로 정정합니다. 여기선 max 함수를 안쓰긴합니다만..
    p = 0 # 판매하고 난 이득을 누적하는 변수에요
     
    for i in range(0, N):
      # 이득을 보려면 내가 구매한 날 이후의 가격이 더 높아야해요
      # 근데 첫날부터 계속 비교하려고하니, 코드 구현이 힘들었어요..
      # 바람을 쐬던 도중 문득 떠오른게 뒤에서부터 비교하면 어떨까라는 생각이 들었어요
        if M[N-i-1] >= maximum: # 뒤에서부터 탐색하는데, 그 날이 최고 값이라면
            maximum = M[N-i-1] # 최고값만 갱신해줄게요. 그 날에 사버리면 이후로 팔 수가 없어요~
        else:
            p += maximum - M[N-i-1] # 고점이 아니면 사야죠. 그래야 1이라도 이득을 볼 수 있죠
    print(f'#{test_case} {p}')

```